---
title: "R Notebook"
output: html_notebook
---

```{r}
library(sampling)
library(laeken)
library(survey)
library(data.table)
library(ggplot2)
library(scales)
library(Rcpp)
library(nonprobsvy)
library(xtable)
library(ncvreg)
source("functions.R") ## to be replaced by package
```

```{r}
sourceCpp("simulations/syspps.cpp")
```

```{r}
seed_for_sim <- 2023-07-14
```

```{r sim-data}
set.seed(seed_for_sim+1)
N <- 20000
n_1 <- 1000
n_2 <- 1000
z1 <- rbinom(N, 1, 0.5)
z2 <- runif(N,0,2)
z3 <- rexp(N,1)
z4 <- rchisq(N, 4)
x1 <- z1
x2 <- z2 + 0.3*z1
x3 <- z3 + 0.2*(x1 + x2)
x4 <- z4 + 0.1*(x1 + x2 + x3)
e <- rnorm(N)

etol <- 1e-8
sigma03 <- stats::uniroot(f = function(s) cor(2+x1+x2+x3+x4, 2+x1+x2+x3+x4+s*e) - 0.3, c(0,20), tol = etol)$root
sigma05 <- stats::uniroot(f = function(s) cor(2+x1+x2+x3+x4, 2+x1+x2+x3+x4+s*e) - 0.5, c(0,20), tol = etol)$root
sigma08 <- stats::uniroot(f = function(s) cor(2+x1+x2+x3+x4, 2+x1+x2+x3+x4+s*e) - 0.8, c(0,20), tol = etol)$root

y1 <- 2+x1+x2+x3+x4+sigma03*e
y2 <- 2+x1+x2+x3+x4+sigma05*e
y3 <- 2+x1+x2+x3+x4+sigma08*e

theta_A1 <- stats::uniroot(f = function(s) sum(plogis(s + 0.1*x1+0.2*x2+0.3*x3+0.2*x4))-n_1, c(-20,0), tol = etol)$root

pA_1 <- plogis(theta_A1 + 0.1*x1+0.2*x2+0.3*x3+0.2*x4)
w_pA_1 <- 1/pA_1

s_B <- stats::uniroot(f = function(s) max(s+x3)/min(s+x3) - 50, c(0, 100), tol = etol)$root
pB_1 <- inclusionprobabilities(s_B + x3, n_1)
pB_2 <- inclusionprobabilities(s_B + x3, n_2)
w_pB_1 <- 1/pB_1
w_pB_2 <- 1/pB_2

pop_data <- data.frame(x1,x2,x3,x4,y1,y2,y3,pA_1,w_pA_1,pB_1,pB_2,w_pB_1,w_pB_2) |> setDT()
head(pop_data)
```

```{r}
x_totals <- with(pop_data, c(sum(x1), sum(x2), sum(x3), sum(x4)))
p_quantiles_est <- seq(0.25, 0.75, 0.25) ## for estimation
#p_quantiles <- seq(0.1, 0.9, 0.1) ## for calibration
p_quantiles <- p_quantiles_est ## for calibration
x2_q <- with(pop_data, quantile(x2, p_quantiles))
x3_q <- with(pop_data, quantile(x3, p_quantiles))
x4_q <- with(pop_data, quantile(x4, p_quantiles))
k_quants <- NROW(p_quantiles)-1
k_quants_est <- NROW(p_quantiles_est)-1
```


```{r}
n_reps <- 1000
results_y3_sample <- 
  results_y2_sample <- 
  results_y1_sample <- matrix(data=0, 
                              nrow = n_reps, 
                              ncol = (1+(k_quants_est+1))*4 + 1 + 3 + (k_quants_est+1)*2)
```

```{r}
set.seed(123124)

  sample_nonprob <- pop_data[which(sampling::UPpoisson(pop_data$pA_1)==1),]
  sample_prob <- pop_data[syspps_cpp(pop_data$pB_1, n_1), ] 
  sample_nonprob$w_naive <- sum(1/sample_prob$pB_1)/n_1
  sample_prob_svy <- svydesign(ids=~1, probs =~pB_1, data = sample_prob)

  q_est <- svyquantile( ~ x2 + x3 + x4, sample_prob_svy, p_quantiles)
  x_totals <- svytotal( ~ x1 + x2 + x3 + x4, sample_prob_svy) |> as.numeric()
  N_hat <- sum(weights(sample_prob_svy))
  
  
  w_res2 <- calib_quantiles(X_q = with(sample_nonprob, cbind(x2, x3, x4)),
                            X =  with(sample_nonprob, cbind(x1, x2, x3, x4)),
                            d = sample_nonprob$w_naive,
                            N = N_hat,
                            totals = x_totals,
                            totals_q = list(q_est$x2[, 1], q_est$x3[, 1], q_est$x4[, 1]),
                            method = "raking",
                            backend = "sampling")
    
    weighted.mean(sample_nonprob$y1, w_res2$w)
```

IPW with quantiles

```{r}
X_q <- w_res2$Xs
colnames(X_q) <- c("(Intercept)", paste0("x2", "_", 1:3), paste0("x3", "_", 1:3), paste0("x4", "_", 1:3),
                      "x1", "x2", "x3", "x4")

totals <- w_res2$totals
names(totals) <- colnames(X_q)
X_q <- as.data.frame(X_q)
q_totals_names <- c("x2_1", "x2_2", "x2_3",  "x3_1", "x3_2", "x3_3","x4_1", "x4_2", "x4_3")
q_totals_names2 <- c("x1", "x2", "x3", "x4")
## for stability
X_q[, q_totals_names] <- X_q[, q_totals_names]*1000
X_q[, q_totals_names2] <- X_q[, q_totals_names2]/1000
totals[q_totals_names] <- totals[q_totals_names]*1000
totals[q_totals_names2] <- totals[q_totals_names2]/1000
X_q$y <- sample_nonprob$y1

res1 <- nonprob(selection =  ~ x2_1 + x2_2 + x2_3 + x3_1 + x3_2 + x3_3 + x4_1 + x4_2 + x4_3,
                #outcome = y ~ x2_1 + x2_2 + x2_3 + x3_1 + x3_2 + x3_3 + x4_1 + x4_2 + x4_3,
                data = X_q,
                pop_totals = totals[c("(Intercept)", 
                                      "x2_1", "x2_2", "x2_3", 
                                      "x3_1", "x3_2", "x3_3",
                                      "x4_1", "x4_2", "x4_3")],
                target = ~ y)

res1$parameters
res1$prop_scores |> hist(breaks = "fd")
www <- res1$weights
XX <- model.matrix(~ x2_1 + x2_2 + x2_3 + x3_1 + x3_2 + x3_3 + x4_1 + x4_2 + x4_3 + x1+x2+x3+x4, X_q)
colSums(XX *www)
weighted.mean(X_q$y, www)
```


